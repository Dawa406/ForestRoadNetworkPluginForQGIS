# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ForestRoads
                                 A QGIS plugin
 Create a network of forest roads based on zones to access, roads to connect
 them to, and a cost matrix.
 The code of the plugin is based on the "LeastCostPath" plugin available on
 https://github.com/Gooong/LeastCostPath. We thank their team for the template.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 10-07-2019
        copyright            : (C) 2019 by Clement Hardy
        email                : clem.hardy@outlook.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
 This script describes the A* algorithm used to find the least cost path between two given
 node, both described by a row and a column of the cost raster.
"""


from math import sqrt
import queue
import random
from qgis.core import (
    QgsFeature,
    QgsGeometry,
    QgsPoint,
    QgsPointXY,
    QgsField,
    QgsFields,
    QgsWkbTypes,
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingException,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterBand,
    QgsProcessingParameterBoolean,
    QgsRaster
)


def dijkstra(start_row_col, end_row_cols, block, raster_layer, feedback=None):
    sqrt2 = sqrt(2)

    # The grid class is used to both contain the matrix of the values
    # of the cost raster, but also to have usefull function for the
    # pathfinding algorithm used here.
    class Grid:
        def __init__(self, matrix):
            self.map = matrix
            # h is the height of the matrix/raster
            self.h = len(matrix)
            # w is the width of the matrix/raster
            self.w = len(matrix[0])

        # Function to test if a coordinate is in the bounds of the matrix/raster
        def _in_bounds(self, id):
            x, y = id
            return 0 <= x < self.w and 0 <= y < self.h

        # Function to test if the raster value of this coordinate is not empty (has a cost to pass it)
        def _passable(self, id):
            y, x = id
            offsetV = raster_layer.dataProvider().identify(Grid._row_col_to_point(id, raster_layer),
                                                           QgsRaster.IdentifyFormat(1),
                                                           raster_layer.dataProvider().extent()).results()[1]
            # return self.map[x][self.h-y] is not None
            return offsetV is not None

        # Function to test a coordinate is both in bound and passable
        def is_valid(self, id):
            return self._in_bounds(id) and self._passable(id)

        # Function to get the eight neighbours of a given cell. They are filtered to get only the valid ones.
        def neighbors(self, id):
            x, y = id
            results = [(x + 1, y), (x, y - 1), (x - 1, y), (x, y + 1),
                       (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1)]
            results = filter(self.is_valid, results)
            return results

        # Static function to calculate the manhattan distance between two cells.
        @staticmethod
        def manhattan_distance(id1, id2):
            x1, y1 = id1
            x2, y2 = id2
            return abs(x1 - x2) + abs(y1 - y2)

        # Function to calculate the minimum manhattan distance between nodes that have been explored yet and the ending
        # nodes for feedback purposes.
        def min_manhattan(self, curr_node, end_nodes):
            return min(map(lambda node: self.manhattan_distance(curr_node, node), end_nodes))

        # Function to get the cost associated for passing from a node to another (current, next)
        def simple_cost(self, cur, nex, feedback, raster_layer):
            # Coordinates of current
            cy, cx = cur
            # Coordinates of next
            ny, nx = nex
            # Get the value associated with the current node
            # currV = self.map[cx][cy]
            currV = raster_layer.dataProvider().identify(Grid._row_col_to_point(cur, raster_layer),
                                                                      QgsRaster.IdentifyFormat(1),
                                                                      raster_layer.dataProvider().extent()).results()[1]
            # Get the value associated with the next node
            # offsetV = self.map[nx][ny]
            offsetV = raster_layer.dataProvider().identify(Grid._row_col_to_point(nex, raster_layer),
                                                                      QgsRaster.IdentifyFormat(1),
                                                                      raster_layer.dataProvider().extent()).results()[1]
            # feedback.pushInfo("Point " + str(Grid._row_col_to_point(nex, raster_layer)) + " has value " + str(offsetV))
            # Check if the nodes are horizontal/vertical neighbours, or diagonals.
            # Adjust the cost to go from one to the other accordingly.
            if cx == nx or cy == ny:
                return (currV + offsetV) / 2
            else:
                return sqrt2 * (currV + offsetV) / 2

        @staticmethod
        def _row_col_to_point(row_col, raster_layer):
            xres = raster_layer.rasterUnitsPerPixelX()
            yres = raster_layer.rasterUnitsPerPixelY()
            extent = raster_layer.dataProvider().extent()

            x = (row_col[1] + 0.5) * xres + extent.xMinimum()
            # There is a dissonance about how I see y axis of the raster
            # and how the program sees it.
            y = (row_col[0] + 0.5) * yres + extent.yMinimum()
            return QgsPointXY(x, y)

    # We create the grid object containing the values of the cost raster
    grid = Grid(block)
    # We create a set of nodes to reach (multiple goal possible)
    end_row_cols = set(end_row_cols)
    # We create a list of nodes to reach for feedback purposes
    end_row_col_list = list(end_row_cols)

    # We create a priority Queue which contains the nodes that are opened but
    # not closed (see functioning of dijkstra algorithm; nodes are opened to
    # initialize their remaining distance, then closed)
    frontier = queue.PriorityQueue()
    # In the frontier, we put tuples containing distance from start, and the node)
    frontier.put((0, start_row_col))
    # We initialize a dictionary of predecessors. For a given node, we'll know
    # which node is his predecessor.
    came_from = {}
    # A dictionary to know what is the distance from a given node to the start.
    cost_so_far = {}
    feedback.pushInfo("Initialization complete for dijkstra algorithm.")

    # If the starting node is invalid, we return nothing
    if not grid.is_valid(start_row_col):
        # feedback.pushInfo("Starting node seems invalid (out of extent of raster or has no value on it)")
        # feedback.pushInfo("Starting node info (rowcol) : " + str(start_row_col))
        # feedback.pushInfo("Starting node info (coordinates) " + str(Grid._row_col_to_point(start_row_col, raster_layer)))
        return None, None, None
    # If the starting node is also an ending node, we return nothing
    if start_row_col in end_row_cols:
        # feedback.pushInfo("Starting node seem to coincide with a ending node")
        return None, None, None

    # update the progress bar
    # total_manhattan = grid.min_manhattan(start_row_col, end_row_col_list)
    # min_manhattan = total_manhattan
    # feedback.setProgress(100 * (1 - min_manhattan / total_manhattan))

    # We initialize the beginning of the loop
    came_from[start_row_col] = None
    cost_so_far[start_row_col] = 0
    current_node = None
    # feedback.pushInfo("Dijkstra loop initialized.")

    # We launch the loop. It will end when there are no more cell to
    # check (impossible to reach an end node), or will be broken when
    # a end node is reached
    while not frontier.empty():
        # We get the node with the smallest distance to start
        # First node will be the start node, of course
        # By using this function, the current node is removed
        # from the frontier.
        current_cost, current_node = frontier.get()
        # feedback.pushInfo("Current node of the loop is " + str(current_node))
        # feedback.pushInfo("Current node corresponds to point " + str(Grid._row_col_to_point(current_node, raster_layer)))

        # update the progress bar if feedback is activated.
        if feedback:
            # The algorithm is canceled if users told it to feedback.
            if feedback.isCanceled():
                return None, None, None

        # We break the loop if the current node is a goal to reach
        if current_node in end_row_cols:
            break

        # If not, we look at each neighbour of the node
        for nex in grid.neighbors(current_node):
            # feedback.pushInfo("Neighbour investigated is " + str(nex))
            # feedback.pushInfo(
                # "Neighbour corresponds to point " + str(Grid._row_col_to_point(nex,raster_layer)))
            # We calculate the distance to goal from this neighbour (which is the one
            # from the current node + the move from current node to neighbour)
            new_cost = cost_so_far[current_node] + grid.simple_cost(current_node, nex, feedback, raster_layer)
            # If the neighbour is not in the dictionary of opened nodes, or if
            # the cost of passing by this neighbour is cheaper than the previous
            # predecessor that this node had
            if nex not in cost_so_far or new_cost < cost_so_far[nex]:
                # We put the current node as predecessor of this neighbour,
                # we put the neighbour in the frontier, and we register
                # the cost to start
                cost_so_far[nex] = new_cost
                frontier.put((new_cost, nex))
                came_from[nex] = current_node


    # When the loop ends, if we did indeed found an end goal :
    if current_node in end_row_cols:
        # We calculate the cost from this end goal to the start
        end_node = current_node
        least_cost = cost_so_far[current_node]
        # We initialize the path object that we are going to return : it is a list.
        # We also make a list of costs.
        path = []
        costs = []
        # From the end node, we add the current node,
        # we register the cost to go to it from the goal,
        # and we take the predecessor as the current node.
        # We stop when there are no more predecessors
        # (meaning current node = starting node)
        while current_node is not None:
            path.append(current_node)
            costs.append(cost_so_far[current_node])
            current_node = came_from[current_node]

        # We reverse the order of the list to start from the start
        path.reverse()
        costs.reverse()
        # We return the path
        return path, costs, end_node
    # If we did not reached a end goal, it was unreachable.
    # We return nothing.
    else:
        return None, None, None
