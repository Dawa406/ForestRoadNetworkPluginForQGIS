# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ForestRoads
                                 A QGIS plugin
 Create a network of forest roads based on zones to access, roads to connect
 them to, and a cost matrix.
 The code of the plugin is based on the "LeastCostPath" plugin available on
 https://github.com/Gooong/LeastCostPath. We thank their team for the template.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 10-07-2019
        copyright            : (C) 2019 by Clement Hardy
        email                : clem.hardy@outlook.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
 This script describes the A* algorithm used to find the least cost path between two given
 node, both described by a row and a column of the cost raster.
"""


from math import sqrt
import queue
import random


def dijkstra(start_row_col, end_row_cols, block, feedback=None):
    sqrt2 = sqrt(2)

    # The grid class is used to both contain the matrix of the values
    # of the cost raster, but also to have usefull function for the
    # pathfinding algorithm used here.
    class Grid:
        def __init__(self, matrix):
            self.map = matrix
            # h is the height of the matrix/raster
            self.h = len(matrix)
            # w is the width of the matrix/raster
            self.w = len(matrix[0])

        # Function to test if a coordinate is in the bounds of the matrix/raster
        def _in_bounds(self, id):
            x, y = id
            return 0 <= x < self.h and 0 <= y < self.w

        # Function to test if the raster value of this coordinate is not empty (has a cost to pass it)
        def _passable(self, id):
            x, y = id
            return self.map[x][y] is not None

        # Function to test a coordinate is both in bound and passable
        def is_valid(self, id):
            return self._in_bounds(id) and self._passable(id)

        # Function to get the eight neighbours of a given cell. They are filtered to get only the valid ones.
        def neighbors(self, id):
            x, y = id
            results = [(x + 1, y), (x, y - 1), (x - 1, y), (x, y + 1),
                       (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1)]
            results = filter(self.is_valid, results)
            return results

        # Static function to calculate the manhattan distance between two cells.
        @staticmethod
        def manhattan_distance(id1, id2):
            x1, y1 = id1
            x2, y2 = id2
            return abs(x1 - x2) + abs(y1 - y2)

        # Function to calculate the minimum manhattan distance between nodes that have been explored yet and the ending
        # nodes for feedback purposes.
        def min_manhattan(self, curr_node, end_nodes):
            return min(map(lambda node: self.manhattan_distance(curr_node, node), end_nodes))

        # Function to get the cost associated for passing from a node to another (current, next)
        def simple_cost(self, cur, nex):
            # Coordinates of current
            cx, cy = cur
            # Coordinates of next
            nx, ny = nex
            # Get the value associated with the current node
            currV = self.map[cx][cy]
            # Get the value associated with the next node
            offsetV = self.map[nx][ny]
            # Check if the nodes are horizontal/vertical neighbours, or diagonals.
            # Adjust the cost to go from one to the other accordingly.
            if cx == nx or cy == ny:
                return (currV + offsetV) / 2
            else:
                return sqrt2 * (currV + offsetV) / 2

    # We create the grid object containing the values of the cost raster
    grid = Grid(block)
    #
    end_row_cols = set(end_row_cols)
    end_row_col_list = list(end_row_cols)

    frontier = queue.PriorityQueue()
    frontier.put((0, start_row_col))
    came_from = {}
    cost_so_far = {}

    if not grid.is_valid(start_row_col):
        return None, None, None
    if start_row_col in end_row_cols:
        return None, None, None

    # update the progress bar
    total_manhattan = grid.min_manhattan(start_row_col, end_row_col_list)
    min_manhattan = total_manhattan
    feedback.setProgress(100 * (1 - min_manhattan / total_manhattan))

    came_from[start_row_col] = None
    cost_so_far[start_row_col] = 0

    current_node = None
    while not frontier.empty():
        current_cost, current_node = frontier.get()

        # update the progress bar
        if feedback:
            if feedback.isCanceled():
                return None, None, None
            curr_manhattan = grid.manhattan_distance(current_node, random.choice(end_row_col_list))
            if curr_manhattan < min_manhattan:
                min_manhattan = curr_manhattan
                feedback.setProgress(100 * (1 - min_manhattan / total_manhattan))

        if current_node in end_row_cols:
            break

        for nex in grid.neighbors(current_node):
            new_cost = cost_so_far[current_node] + grid.simple_cost(current_node, nex)
            if nex not in cost_so_far or new_cost < cost_so_far[nex]:
                cost_so_far[nex] = new_cost
                frontier.put((new_cost, nex))
                came_from[nex] = current_node

    if current_node in end_row_cols:
        end_node = current_node
        least_cost = cost_so_far[current_node]
        path = []
        costs = []
        while current_node is not None:
            path.append(current_node)
            costs.append(cost_so_far[current_node])
            current_node = came_from[current_node]

        path.reverse()
        costs.reverse()
        return path, costs, end_node
    else:
        return None, None, None
