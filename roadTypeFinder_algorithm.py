# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ForestRoads
                                 A QGIS plugin
 Create a network of forest roads based on zones to access, roads to connect
 them to, and a cost matrix.
 The code of the plugin is based on the "LeastCostPath" plugin available on
 https://github.com/Gooong/LeastCostPath. We thank their team for the template.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 10-07-2019
        copyright            : (C) 2019 by Clement Hardy
        email                : clem.hardy@outlook.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
 This script describes the algorithm used to determine the type of the roads.
"""

__author__ = 'clem.hardy@outlook.fr'
__date__ = 'Currently in work'
__copyright__ = '(C) 2019 by Clement Hardy'

# We load every function necessary from the QIS packages.
import random
import queue
import math
from PyQt5.QtCore import QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from qgis.core import (
    QgsFeature,
    QgsGeometry,
    QgsPoint,
    QgsPointXY,
    QgsField,
    QgsFields,
    QgsWkbTypes,
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingException,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterBand,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterNumber,
    QgsProcessingParameterEnum
)

# The algorithm class heritates from the algorithm class of QGIS.
# There, it can register different parameter during initialization
# that can be put into variables using "
class RoadTypeFinderAlgorithm(QgsProcessingAlgorithm):
    """
    Class that described the algorithm, that will be launched
    via the provider, itself launched via initialization of
    the plugin.

    The algorithm takes 4 entries :

    - A cost raster
    - The raster band to use for the cost
    - The layer with the polygons of zones to access
    - The layer with the roads (lines) that they can be connected to
    by the generated roads
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT_ROAD_NETWORK = 'INPUT_ROAD_NETWORK'
    INPUT_ENDING_POINTS = 'INPUT_ENDING_POINTS'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties. Theses will be asked to the user.
        """

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_ROAD_NETWORK,
                self.tr('Road network whose road types must be determined'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_ENDING_POINTS,
                self.tr('The end points (connections to main road network) of the network'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output for the forest road network')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        road_network = self.parameterAsVectorLayer(
            parameters,
            self.INPUT_ROAD_NETWORK,
            context
        )

        ending_points = self.parameterAsVectorLayer(
            parameters,
            self.INPUT_ENDING_POINTS,
            context
        )

        # If source was not found, throw an exception to indicate that the algorithm
        # encountered a fatal error. The exception text can be any string, but in this
        # case we use the pre-built invalidSourceError method to return a standard
        # helper text for when a source cannot be evaluated
        if road_network is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_ROAD_NETWORK))
        if ending_points is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, self.INPUT_ENDING_POINTS))

        # We try to see if there are divergence between the CRSs of the inputs
        if road_network.crs() != ending_points.sourceCrs():
            raise QgsProcessingException(self.tr("ERROR: The input layers have different CRSs."))

        # We initialize the "sink", an object that will make use able to create an output.
        # First, we create the fields for the attributes of our lines as outputs.
        # They will only have one field :
        sink_fields = RoadTypeFinderHelper.create_fields()
        # We indicate that our output will be a line, stored in WBK format.
        output_geometry_type = QgsWkbTypes.LineString
        # Finally, we create the field object and register the destination ID of it.
        # This sink will be based on the OUTPUT parameter we registered during initialization,
        # will have the fields and the geometry type we just created, and the same CRS as the cost raster.
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            fields=sink_fields,
            geometryType=output_geometry_type,
            crs=road_network.crs(),
        )

        # If sink was not created, throw an exception to indicate that the algorithm
        # encountered a fatal error. The exception text can be any string, but in this
        # case we use the pre-built invalidSinkError method to return a standard
        # helper text for when a sink cannot be evaluated
        if sink is None:
            raise QgsProcessingException(self.invalidSinkError(parameters, self.OUTPUT))

        feedback.pushInfo(self.tr("Scanning lines..."))
        # For each line feature in the roadnetwork, we initialize an object of class "line"
        multi_line = set(road_network.getFeatures())
        setOfRoadsAsLines = set()
        ID = 0
        # We are carefull to treat each individual line of the given layer;
        # for that, we have to treat the case of a multiline geometry, or a simple line.
        for featureline in multi_line:
            featureline = featureline.geometry()

            # Case of multiline
            if featureline.wkbType() == QgsWkbTypes.MultiLineString:
                multi_line = featureline.asMultiPolyline()
                for line in multi_line:
                    setOfRoadsAsLines.add(LineForAlgorithm(line, ID))
                    ID += 1

            # Case of lines
            elif featureline.wkbType() == QgsWkbTypes.LineString:
                line = featureline.asPolyline()
                setOfRoadsAsLines.add(LineForAlgorithm(line, ID))
                ID += 1

            if feedback.isCanceled():
                raise QgsProcessingException(self.tr("ERROR: Operation was cancelled."))

        # First, we transform the ending points into a list of QgsPointXY we can compare to our lines.
        tempSetOfEndingPoints = ending_points.getFeatures()
        setOfMultiEndingPoints = [endingPoint.geometry().asMultiPoint() for endingPoint in list(tempSetOfEndingPoints)]
        setOfEndingPoints = set()
        for multiEnginPoints in setOfMultiEndingPoints:
            for point in multiEnginPoints:
                setOfEndingPoints.add(point)

        # Then, we update our line objects to reflect network structure. See function in Line class.
        feedback.pushInfo(self.tr("Scanning network structure..."))

        feedbackProgress = 0
        for line in setOfRoadsAsLines:
            line.initializeRelationToNetwork(setOfRoadsAsLines, setOfEndingPoints)
            if feedback.isCanceled():
                raise QgsProcessingException(self.tr("ERROR: Operation was cancelled."))
            feedbackProgress += 1
            feedback.setProgress(100 * (feedbackProgress / len(setOfRoadsAsLines)))

        # Once it's done, we have to give a direction to each line object. Again, see function in Line class.
        feedback.pushInfo(self.tr("Scanning network direction..."))
        feedbackProgress = 0
        for line in setOfRoadsAsLines:
            line.initializeDownstreamDirection(setOfEndingPoints)
            if feedback.isCanceled():
                raise QgsProcessingException(self.tr("ERROR: Operation was cancelled."))
            feedbackProgress += 1
            feedback.setProgress(100 * (feedbackProgress / len(setOfRoadsAsLines)))

        # Now, we can compute the fluxes that go through the network.
        # We will start with the "leaves" of the network, from which the wood will come.
        # We get them in a set.
        setOfLeafLines = set([line for line in list(setOfRoadsAsLines) if line.isALeafOfTheNetwork])

        # We initialize the objects for the loop.
        frontier = queue.Queue()
        setOfLinesToReturn = set()
        for line in setOfLeafLines:
            frontier.put(line)

        feedback.pushInfo(self.tr("Commencing flux algorithm..."))
        # We loop : The loop will end when no more line is in an "open" status.
        # WARNING : if the directions of the lines are not correct, this will become an infinite loop !
        linesAlreadyConsidered = set()
        while not frontier.empty():

            if feedback.isCanceled():
                raise QgsProcessingException(self.tr("ERROR: Operation was cancelled."))

            line = frontier.get()
            # If the line have be fluxed by all of its upstream neighbors,
            # we make it flux to its downstream neighbors, and we put the neighbors in the
            # frontier
            if line.checkIfAllUpstreamHaveFluxed():
                line.fluxToDownstreamNeighbors(feedback)
                setOfLinesToReturn.add(line)
                linesAlreadyConsidered.add(line)
                neighbors = line.getNeighborsDownstream()
                if len(neighbors) != 0:
                    for neighbour in [neighbour for neighbour in neighbors if neighbour not in linesAlreadyConsidered]:
                        # We open the neighbour downstream if they are not already considered/fluxed.
                        frontier.put(neighbour)
            # If not, we re-add the line in the frontier. It will have to be considered later, once
            # that all of its neighbors are fluxed.
            # WARNING : This is where the infinite loop can generate if a culvet is created.
            else:
                frontier.put(line)

            feedback.setProgress(100 * (len(setOfLinesToReturn) / len(setOfRoadsAsLines)))

        feedback.pushInfo(self.tr("Preparing outputs..."))
        # Once that all of this is done, we prepare the output.
        # For every path we create, we save it as a line and put it into the sink !
        for line in setOfLinesToReturn:
            # With the total cost which is the last item in our accumulated cost list,
            # we create the PolyLine that will be returned as a vector.
            path_feature = RoadTypeFinderHelper.create_path_feature_from_points(line.lineFeature,
                                                                                line.uniqueID,
                                                                                int(math.floor(line.flux)),
                                                                                sink_fields)
            # Into the sink that serves as our output, we put the PolyLines from the list of lines we created
            # one by one
            sink.addFeature(path_feature, QgsFeatureSink.FastInsert)

        # When all is done, we return our output that is linked to the sink.
        return {self.OUTPUT: dest_id}

    # Here are different functions used by QGIS to name and define the algorithm
    # to the user.
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Road Type Finder'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        # We don't need it right now, as our plugin only have one algorithm
        return ''

    # Function used for translation. Called every time something needs to be
    # Translated
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return RoadTypeFinderAlgorithm()

    def helpUrl(self):
        # No help URL for now; Github of the project could be nice once done.
        return ''

    def shortHelpString(self):
        return self.tr("""
        This algorithm determine the type (primary, secondary, tertiary...) of roads in a forest road network based on their position relative to a connection to a main road network (non-forest roads).
        
        **Parameters:**
          
          Please ensure all the input layers have the same CRS.
        
          - Road Network : a forest road network where every line is split at intersections. They can be splitted even more, but they HAVE to be splitted at intersections. You can use the "Split with lines" tools for that in QGIS.
         
          - Ending points : points that correspond EXACTLY to the ending of the network, meaning its connection to the main road network. WARNING : If those points do not correspond exactly with the end of a line or the end of your network, the algorithm will have problems to complete. You can use the "Line intersections" tool for that in QGIS.
         
         WARNING : The algorithm WILL MAKE AN INFINITE LOOP if the network is not properly set up for analysis. See documentation or GitHub page to avoid issues.
        """)

    def shortDescription(self):
        return self.tr('Determine the type (primary, secondary, tertiary) of roads in a forest road network.')

    # Path to the icon of the algorithm
    def svgIconPath(self):
        return '.icon.png'

    def tags(self):
        return ['type', 'primary', 'secondary', 'tertiary', 'roads', 'analysis', 'road', 'network', 'forest']


# The "Line" object used in the algorithm
class LineForAlgorithm:
    """Class used for the algorithm. To initialize, a line feature should be provided"""

    def __init__(self, lineFeature, ID):
        """Constructor for the line class"""
        self.uniqueID = ID  # Used to identify the line.
        self.lineFeature = lineFeature  # As Polyline gives a list of points
        # Ending 1 and 2 are QgsPointXY.
        self.ending1 = self.lineFeature[0]
        self.ending2 = self.lineFeature[-1]
        # These sets are temporary, and replaced by Downstream/upstream once they have been identified.
        self.linesConnectedToEnding1 = set()
        self.linesConnectedToEnding2 = set()
        # Just boxed to put the above sets in, but properly identified.
        self.linesConnectedDownstream = set()
        self.linesConnectedUpstream = set()
        # The flux of wood going through our road
        self.flux = 0
        # Indicators to know if this line is a leaf or a root of the network
        self.isALeafOfTheNetwork = False
        self.isARootOfTheNetwork = False
        # Indicator to know if the line have already given its flux to its downstream neighbors, so that it
        # doesn't do it again by mistake.
        self.haveFluxed = False

    def initializeRelationToNetwork(self, listOfLinesForAlgorithm, endingPoints):
        """Initialize the lines that are connected to this line, and we also check if the line is a "leaf" or not"""

        # For all the other lines in the network, we check which one touches the endings of this one.
        for otherLine in listOfLinesForAlgorithm:
            if otherLine.uniqueID != self.uniqueID:
                if self.ending1.compare(otherLine.ending1, 1) or self.ending1.compare(otherLine.ending2,1):
                    self.linesConnectedToEnding1.add(otherLine)
                elif self.ending2.compare(otherLine.ending1, 1) or self.ending2.compare(otherLine.ending2,1):
                    self.linesConnectedToEnding2.add(otherLine)

        # To check if the line is a leaf (an outward ending of the network) or a root, we check if it has an ending
        # without neighbors, and if this ending coincide with an end point. If it does not for any ending point,
        # then the line is a leaf of the network.
        if len(self.linesConnectedToEnding1) == 0:
            for endingPoint in endingPoints:
                if self.ending1.compare(endingPoint, 1):
                    self.isARootOfTheNetwork = True
                    break
            if not self.isARootOfTheNetwork:
                self.isALeafOfTheNetwork = True
                self.flux = 1

        elif len(self.linesConnectedToEnding2) == 0:
            for endingPoint in endingPoints:
                if self.ending2.compare(endingPoint, 1):
                    self.isARootOfTheNetwork = True
                    break
            if not self.isARootOfTheNetwork:
                self.isALeafOfTheNetwork = True
                self.flux = 1

    # This function will find and register which ending is downstream, and which is upstream.
    # We use a dijkstra search for that.
    def initializeDownstreamDirection(self, endingPoints):
        """This function will find and register which ending is downstream, and which is upstream.
           We use a kind of dijkstra search for that."""
        # First, we make the case of our line being a leaf or a root. If that's the case, it's relatively
        # easy to deduce where is the downstream or the upstream.
        if self.isALeafOfTheNetwork:
            if len(self.linesConnectedToEnding1) == 0:
                self.linesConnectedDownstream = self.linesConnectedToEnding2
                self.linesConnectedUpstream = self.linesConnectedToEnding1
            else:
                self.linesConnectedDownstream = self.linesConnectedToEnding1
                self.linesConnectedUpstream = self.linesConnectedToEnding2
        elif self.isARootOfTheNetwork:
            if len(self.linesConnectedToEnding1) == 0:
                self.linesConnectedDownstream = self.linesConnectedToEnding1
                self.linesConnectedUpstream = self.linesConnectedToEnding2
            else:
                self.linesConnectedDownstream = self.linesConnectedToEnding2
                self.linesConnectedUpstream = self.linesConnectedToEnding1
        else:
            # Now for the case of a line which is not a root, or a leaf.
            # To find upstream and downstream, we randomly take one of the endings of our line (the ending1).
            # Then, we start a kind of dijkstra search (we are not looking for least cost path) until we find
            # a root line or not. If we find it, then ending1 is in the direction of downstream; if not, it is
            # upstream.

            # To start the search, we look at the neighbours touching the Ending1.
            frontier = queue.Queue()
            for line in self.linesConnectedToEnding1:
                frontier.put(line)
            # We initialize a set that will allow us to avoid looping in the search.
            linesAlreadyConsidered = set()
            linesAlreadyConsidered.add(self)
            foundRoot = False

            while not frontier.empty():
                curentLine = frontier.get()
                linesAlreadyConsidered.add(curentLine)
                neighbors = curentLine.linesConnectedToEnding1 | curentLine.linesConnectedToEnding2

                # We will only considered the lines that have not been considered before.
                for neighbour in [neighbour for neighbour in neighbors if neighbour not in linesAlreadyConsidered]:
                    # If the neighbour is the root, we can stop the search.
                    if neighbour.isARootOfTheNetwork:
                        self.linesConnectedDownstream = self.linesConnectedToEnding1
                        self.linesConnectedUpstream = self.linesConnectedToEnding2
                        frontier = queue.Queue()
                        foundRoot = True
                        break
                    # If not, we keep the search going on and add the neighbour to be looked at.
                    else:
                        frontier.put(neighbour)
            # If we didn't found the root during the search, that means that ending 1 is not downstream. He must then
            # be upstream.
            if not foundRoot:
                self.linesConnectedDownstream = self.linesConnectedToEnding2
                self.linesConnectedUpstream = self.linesConnectedToEnding1

        # If the function ended without use being able to determine at least a upstream or a downstream,
        # this could be a problem. We raise an exception with details about the line.
        if len(self.linesConnectedDownstream) == 0 and len(self.linesConnectedUpstream) == 0:
            raise QgsProcessingException("ERROR: For a certain line, Upstream and Downstream could not be determined."
                                         "Problematic line is between those two points : " + str(self.ending1)
                                         + " and " + str(self.ending2) + ". Please check if your network have been cut into"
                                        "pieces via the \"split lines with lines\" tool of QGIS.")
        if len(self.linesConnectedDownstream) == 0 and not self.isARootOfTheNetwork:
            raise QgsProcessingException("ERROR: For a certain line that is not a root, Downstream could not be determined."
                                         "Problematic line is between those two points : " + str(self.ending1)
                                         + " and " + str(self.ending2) + ". Please check if your network have been cut into"
                                        "pieces via the \"split lines with lines\" tool of QGIS.")

    def getNeighborsDownstream(self):
        """For this function to work, the network initialization must be done. Also, it must be called during
        the algorithm so as force the fact that one of the neighbors must have a smaller flux.
        The downstream neighbors are going to be the one who are connect to this line by their upstream point !"""
        downStreamNeighbors = set()
        for neighbour in self.linesConnectedDownstream:
            if self in neighbour.linesConnectedUpstream:
                downStreamNeighbors.add(neighbour)
        return downStreamNeighbors

    def getNeighborsUpstream(self):
        """For this function to work, the network initialization must be done. Also, it must be called during
        the algorithm so as force the fact that one of the neighbors must have a smaller flux.
        The downstream neighbors are going to be the one who are connect to this line by their upstream point !"""
        upStreamNeighbors = set()
        for neighbour in self.linesConnectedUpstream:
            if self in neighbour.linesConnectedDownstream:
                upStreamNeighbors.add(neighbour)
        return upStreamNeighbors

    def fluxToDownstreamNeighbors(self, feedback):
        """This function adds the flux coming from this line to the neighbours downstream"""

        if not self.haveFluxed:
            downStreamNeighbors = self.getNeighborsDownstream()
            for neighbour in downStreamNeighbors:
                neighbour.flux = neighbour.flux + (self.flux / len(downStreamNeighbors))
                # If their is a negative flux, something is really wrong. We raise an exception.
                if neighbour.flux < 0:
                    raise QgsProcessingException("ERROR: A line flux became negative ! We were trying to add a flux of"
                                                 "quantity " + str((self.flux / len(downStreamNeighbors)))
                                                 + "from the line that is between the points " + str(self.ending1)
                                                 + " and " + str(self.ending2) + " and to the line that is between the"
                                                 " points " + str(neighbour.ending1) + " and " + str(neighbour.ending2))

            self.haveFluxed = True

    def checkIfAllUpstreamHaveFluxed(self):
        """This function checks if the upstream neighbors have all fluxed into this line so that
        we can flux this one in the right order to its own downstream neighbors."""

        # Case of the lines that are leaves
        if self.isALeafOfTheNetwork:
            return True
        # If not a leaf, we look at all of the upstream neighbors and check if they have fluxed.
        else:
            theyHaveAllFluxed = True
            upStreamNeighbors = self.getNeighborsUpstream()
            for neighbour in upStreamNeighbors:
                if not neighbour.haveFluxed:
                    theyHaveAllFluxed = False
                    break
            return theyHaveAllFluxed

# Methods to help the algorithm; all static, do not need to initialize an object of this class.
class RoadTypeFinderHelper:

    # Function to create the fields for the attributes that we register with the lines.
    @staticmethod
    def create_fields():
        # Create an ID field to identify the lines
        id_field = QgsField("id", QVariant.Int, "integer", 10, 1)
        # Create the field containing the flux value
        flux_field = QgsField("flux", QVariant.Int, "integer", 20, 1)
        # Then, we create a container of multiple fields
        fields = QgsFields()
        # We add the fields to the container
        fields.append(id_field)
        fields.append(flux_field)
        # We return the container with our fields.
        return fields

    # Function to create a polyline with the list of qgs.pointXY
    @staticmethod
    def create_path_feature_from_points(path_points, ID, flux, fields):
        # We create the geometry of the polyline
        polyline = QgsGeometry.fromPolylineXY(path_points)
        # We retrieve the fields and add them to the feature
        feature = QgsFeature(fields)
        id_index = feature.fieldNameIndex("id")
        feature.setAttribute(id_index, ID)
        flux_index = feature.fieldNameIndex("flux")
        feature.setAttribute(flux_index, flux)
        # We add the geometry to the feature
        feature.setGeometry(polyline)
        return feature


